// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package dbgen

import (
	"context"
	"time"
)

const archiveCurrentEvents = `-- name: ArchiveCurrentEvents :exec
UPDATE events SET archive_id = ? WHERE archive_id IS NULL
`

func (q *Queries) ArchiveCurrentEvents(ctx context.Context, archiveID *int64) error {
	_, err := q.db.ExecContext(ctx, archiveCurrentEvents, archiveID)
	return err
}

const countCurrentEvents = `-- name: CountCurrentEvents :one
SELECT COUNT(*) FROM events WHERE archive_id IS NULL
`

func (q *Queries) CountCurrentEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCurrentEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEvents = `-- name: CountEvents :one
SELECT COUNT(*) FROM events
`

func (q *Queries) CountEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createArchive = `-- name: CreateArchive :one
INSERT INTO archives (name, event_count, created_at)
VALUES (?, ?, ?)
RETURNING id
`

type CreateArchiveParams struct {
	Name       *string   `json:"name"`
	EventCount int64     `json:"event_count"`
	CreatedAt  time.Time `json:"created_at"`
}

func (q *Queries) CreateArchive(ctx context.Context, arg CreateArchiveParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createArchive, arg.Name, arg.EventCount, arg.CreatedAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteArchive = `-- name: DeleteArchive :exec
DELETE FROM archives WHERE id = ?
`

func (q *Queries) DeleteArchive(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteArchive, id)
	return err
}

const deleteArchiveEvents = `-- name: DeleteArchiveEvents :exec
DELETE FROM events WHERE archive_id = ?
`

func (q *Queries) DeleteArchiveEvents(ctx context.Context, archiveID *int64) error {
	_, err := q.db.ExecContext(ctx, deleteArchiveEvents, archiveID)
	return err
}

const deleteArchiveImages = `-- name: DeleteArchiveImages :exec
DELETE FROM images WHERE event_id IN (SELECT id FROM events WHERE archive_id = ?)
`

func (q *Queries) DeleteArchiveImages(ctx context.Context, archiveID *int64) error {
	_, err := q.db.ExecContext(ctx, deleteArchiveImages, archiveID)
	return err
}

const deleteCompareResultsByArchive = `-- name: DeleteCompareResultsByArchive :exec
DELETE FROM compare_results WHERE archive_id = ?
`

func (q *Queries) DeleteCompareResultsByArchive(ctx context.Context, archiveID int64) error {
	_, err := q.db.ExecContext(ctx, deleteCompareResultsByArchive, archiveID)
	return err
}

const getArchiveByID = `-- name: GetArchiveByID :one
SELECT id, name, event_count, created_at FROM archives WHERE id = ?
`

func (q *Queries) GetArchiveByID(ctx context.Context, id int64) (Archive, error) {
	row := q.db.QueryRowContext(ctx, getArchiveByID, id)
	var i Archive
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EventCount,
		&i.CreatedAt,
	)
	return i, err
}

const getArchivedEventFiles = `-- name: GetArchivedEventFiles :many
SELECT e.id, e.json_filename, i.disk_filename
FROM events e
LEFT JOIN images i ON i.event_id = e.id
WHERE e.archive_id = ?
`

type GetArchivedEventFilesRow struct {
	ID           int64   `json:"id"`
	JsonFilename *string `json:"json_filename"`
	DiskFilename *string `json:"disk_filename"`
}

func (q *Queries) GetArchivedEventFiles(ctx context.Context, archiveID *int64) ([]GetArchivedEventFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, getArchivedEventFiles, archiveID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetArchivedEventFilesRow{}
	for rows.Next() {
		var i GetArchivedEventFilesRow
		if err := rows.Scan(&i.ID, &i.JsonFilename, &i.DiskFilename); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArchivedEvents = `-- name: GetArchivedEvents :many
SELECT 
    e.id, e.car_id, e.plate_utf8, e.car_state, e.sensor_provider_id, 
    e.event_datetime, e.created_at, e.plate_country, e.plate_region, e.plate_region_code,
    e.vehicle_make, e.vehicle_model, e.vehicle_color, e.vehicle_type,
    e.plate_confidence, e.confidence_mmr, e.confidence_color,
    e.json_filename,
    COALESCE((SELECT id FROM images WHERE event_id = e.id AND image_type = 'plate' LIMIT 1),
             (SELECT id FROM images WHERE event_id = e.id ORDER BY id LIMIT 1 OFFSET 1), 0) as plate_image_id,
    COALESCE((SELECT id FROM images WHERE event_id = e.id AND image_type = 'vehicle' LIMIT 1),
             (SELECT id FROM images WHERE event_id = e.id ORDER BY id LIMIT 1), 0) as vehicle_image_id
FROM events e
WHERE e.archive_id = ?
ORDER BY e.created_at DESC
`

type GetArchivedEventsRow struct {
	ID               int64       `json:"id"`
	CarID            string      `json:"car_id"`
	PlateUtf8        *string     `json:"plate_utf8"`
	CarState         *string     `json:"car_state"`
	SensorProviderID *string     `json:"sensor_provider_id"`
	EventDatetime    *string     `json:"event_datetime"`
	CreatedAt        time.Time   `json:"created_at"`
	PlateCountry     *string     `json:"plate_country"`
	PlateRegion      *string     `json:"plate_region"`
	PlateRegionCode  *string     `json:"plate_region_code"`
	VehicleMake      *string     `json:"vehicle_make"`
	VehicleModel     *string     `json:"vehicle_model"`
	VehicleColor     *string     `json:"vehicle_color"`
	VehicleType      *string     `json:"vehicle_type"`
	PlateConfidence  *float64    `json:"plate_confidence"`
	ConfidenceMmr    *string     `json:"confidence_mmr"`
	ConfidenceColor  *string     `json:"confidence_color"`
	JsonFilename     *string     `json:"json_filename"`
	PlateImageID     interface{} `json:"plate_image_id"`
	VehicleImageID   interface{} `json:"vehicle_image_id"`
}

func (q *Queries) GetArchivedEvents(ctx context.Context, archiveID *int64) ([]GetArchivedEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getArchivedEvents, archiveID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetArchivedEventsRow{}
	for rows.Next() {
		var i GetArchivedEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.CarID,
			&i.PlateUtf8,
			&i.CarState,
			&i.SensorProviderID,
			&i.EventDatetime,
			&i.CreatedAt,
			&i.PlateCountry,
			&i.PlateRegion,
			&i.PlateRegionCode,
			&i.VehicleMake,
			&i.VehicleModel,
			&i.VehicleColor,
			&i.VehicleType,
			&i.PlateConfidence,
			&i.ConfidenceMmr,
			&i.ConfidenceColor,
			&i.JsonFilename,
			&i.PlateImageID,
			&i.VehicleImageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArchives = `-- name: GetArchives :many
SELECT id, name, event_count, created_at FROM archives ORDER BY created_at DESC
`

func (q *Queries) GetArchives(ctx context.Context) ([]Archive, error) {
	rows, err := q.db.QueryContext(ctx, getArchives)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Archive{}
	for rows.Next() {
		var i Archive
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.EventCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompareResults = `-- name: GetCompareResults :many
SELECT event_id, field, is_incorrect FROM compare_results WHERE archive_id = ?
`

type GetCompareResultsRow struct {
	EventID     int64  `json:"event_id"`
	Field       string `json:"field"`
	IsIncorrect bool   `json:"is_incorrect"`
}

func (q *Queries) GetCompareResults(ctx context.Context, archiveID int64) ([]GetCompareResultsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompareResults, archiveID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompareResultsRow{}
	for rows.Next() {
		var i GetCompareResultsRow
		if err := rows.Scan(&i.EventID, &i.Field, &i.IsIncorrect); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventByID = `-- name: GetEventByID :one
SELECT id, car_id, plate_utf8, car_state, sensor_provider_id, event_datetime, capture_timestamp, plate_country, plate_region, plate_confidence, geotag_lat, geotag_lon, vehicle_make, vehicle_model, vehicle_color, camera_serial, camera_ip, raw_json, created_at, archive_id, json_filename, vehicle_type, confidence_mmr, confidence_color, plate_region_code FROM events WHERE id = ?
`

func (q *Queries) GetEventByID(ctx context.Context, id int64) (Event, error) {
	row := q.db.QueryRowContext(ctx, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CarID,
		&i.PlateUtf8,
		&i.CarState,
		&i.SensorProviderID,
		&i.EventDatetime,
		&i.CaptureTimestamp,
		&i.PlateCountry,
		&i.PlateRegion,
		&i.PlateConfidence,
		&i.GeotagLat,
		&i.GeotagLon,
		&i.VehicleMake,
		&i.VehicleModel,
		&i.VehicleColor,
		&i.CameraSerial,
		&i.CameraIp,
		&i.RawJson,
		&i.CreatedAt,
		&i.ArchiveID,
		&i.JsonFilename,
		&i.VehicleType,
		&i.ConfidenceMmr,
		&i.ConfidenceColor,
		&i.PlateRegionCode,
	)
	return i, err
}

const getImageData = `-- name: GetImageData :one
SELECT image_data FROM images WHERE id = ?
`

func (q *Queries) GetImageData(ctx context.Context, id int64) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getImageData, id)
	var image_data []byte
	err := row.Scan(&image_data)
	return image_data, err
}

const getImageWithFilename = `-- name: GetImageWithFilename :one
SELECT id, event_id, image_type, filename, disk_filename, created_at FROM images WHERE id = ?
`

type GetImageWithFilenameRow struct {
	ID           int64     `json:"id"`
	EventID      int64     `json:"event_id"`
	ImageType    *string   `json:"image_type"`
	Filename     *string   `json:"filename"`
	DiskFilename *string   `json:"disk_filename"`
	CreatedAt    time.Time `json:"created_at"`
}

func (q *Queries) GetImageWithFilename(ctx context.Context, id int64) (GetImageWithFilenameRow, error) {
	row := q.db.QueryRowContext(ctx, getImageWithFilename, id)
	var i GetImageWithFilenameRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.ImageType,
		&i.Filename,
		&i.DiskFilename,
		&i.CreatedAt,
	)
	return i, err
}

const getImagesByEventID = `-- name: GetImagesByEventID :many
SELECT id, image_type, filename, created_at FROM images WHERE event_id = ?
`

type GetImagesByEventIDRow struct {
	ID        int64     `json:"id"`
	ImageType *string   `json:"image_type"`
	Filename  *string   `json:"filename"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) GetImagesByEventID(ctx context.Context, eventID int64) ([]GetImagesByEventIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getImagesByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetImagesByEventIDRow{}
	for rows.Next() {
		var i GetImagesByEventIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ImageType,
			&i.Filename,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentEvents = `-- name: GetRecentEvents :many
SELECT 
    e.id, e.car_id, e.plate_utf8, e.car_state, e.sensor_provider_id, 
    e.event_datetime, e.created_at, e.plate_country, e.plate_region, e.plate_region_code,
    e.vehicle_make, e.vehicle_model, e.vehicle_color, e.vehicle_type,
    e.plate_confidence, e.confidence_mmr, e.confidence_color,
    e.json_filename,
    COALESCE((SELECT id FROM images WHERE event_id = e.id AND image_type = 'plate' LIMIT 1),
             (SELECT id FROM images WHERE event_id = e.id ORDER BY id LIMIT 1 OFFSET 1), 0) as plate_image_id,
    COALESCE((SELECT id FROM images WHERE event_id = e.id AND image_type = 'vehicle' LIMIT 1),
             (SELECT id FROM images WHERE event_id = e.id ORDER BY id LIMIT 1), 0) as vehicle_image_id
FROM events e
WHERE e.archive_id IS NULL
ORDER BY e.created_at DESC
LIMIT ?
`

type GetRecentEventsRow struct {
	ID               int64       `json:"id"`
	CarID            string      `json:"car_id"`
	PlateUtf8        *string     `json:"plate_utf8"`
	CarState         *string     `json:"car_state"`
	SensorProviderID *string     `json:"sensor_provider_id"`
	EventDatetime    *string     `json:"event_datetime"`
	CreatedAt        time.Time   `json:"created_at"`
	PlateCountry     *string     `json:"plate_country"`
	PlateRegion      *string     `json:"plate_region"`
	PlateRegionCode  *string     `json:"plate_region_code"`
	VehicleMake      *string     `json:"vehicle_make"`
	VehicleModel     *string     `json:"vehicle_model"`
	VehicleColor     *string     `json:"vehicle_color"`
	VehicleType      *string     `json:"vehicle_type"`
	PlateConfidence  *float64    `json:"plate_confidence"`
	ConfidenceMmr    *string     `json:"confidence_mmr"`
	ConfidenceColor  *string     `json:"confidence_color"`
	JsonFilename     *string     `json:"json_filename"`
	PlateImageID     interface{} `json:"plate_image_id"`
	VehicleImageID   interface{} `json:"vehicle_image_id"`
}

func (q *Queries) GetRecentEvents(ctx context.Context, limit int64) ([]GetRecentEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentEventsRow{}
	for rows.Next() {
		var i GetRecentEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.CarID,
			&i.PlateUtf8,
			&i.CarState,
			&i.SensorProviderID,
			&i.EventDatetime,
			&i.CreatedAt,
			&i.PlateCountry,
			&i.PlateRegion,
			&i.PlateRegionCode,
			&i.VehicleMake,
			&i.VehicleModel,
			&i.VehicleColor,
			&i.VehicleType,
			&i.PlateConfidence,
			&i.ConfidenceMmr,
			&i.ConfidenceColor,
			&i.JsonFilename,
			&i.PlateImageID,
			&i.VehicleImageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEvent = `-- name: InsertEvent :one
INSERT INTO events (
    car_id, plate_utf8, car_state, sensor_provider_id,
    event_datetime, capture_timestamp, plate_country, plate_region, plate_region_code, plate_confidence,
    geotag_lat, geotag_lon, vehicle_make, vehicle_model, vehicle_color,
    vehicle_type, confidence_mmr, confidence_color,
    camera_serial, camera_ip, raw_json, created_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING id
`

type InsertEventParams struct {
	CarID            string    `json:"car_id"`
	PlateUtf8        *string   `json:"plate_utf8"`
	CarState         *string   `json:"car_state"`
	SensorProviderID *string   `json:"sensor_provider_id"`
	EventDatetime    *string   `json:"event_datetime"`
	CaptureTimestamp *string   `json:"capture_timestamp"`
	PlateCountry     *string   `json:"plate_country"`
	PlateRegion      *string   `json:"plate_region"`
	PlateRegionCode  *string   `json:"plate_region_code"`
	PlateConfidence  *float64  `json:"plate_confidence"`
	GeotagLat        *float64  `json:"geotag_lat"`
	GeotagLon        *float64  `json:"geotag_lon"`
	VehicleMake      *string   `json:"vehicle_make"`
	VehicleModel     *string   `json:"vehicle_model"`
	VehicleColor     *string   `json:"vehicle_color"`
	VehicleType      *string   `json:"vehicle_type"`
	ConfidenceMmr    *string   `json:"confidence_mmr"`
	ConfidenceColor  *string   `json:"confidence_color"`
	CameraSerial     *string   `json:"camera_serial"`
	CameraIp         *string   `json:"camera_ip"`
	RawJson          *string   `json:"raw_json"`
	CreatedAt        time.Time `json:"created_at"`
}

func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertEvent,
		arg.CarID,
		arg.PlateUtf8,
		arg.CarState,
		arg.SensorProviderID,
		arg.EventDatetime,
		arg.CaptureTimestamp,
		arg.PlateCountry,
		arg.PlateRegion,
		arg.PlateRegionCode,
		arg.PlateConfidence,
		arg.GeotagLat,
		arg.GeotagLon,
		arg.VehicleMake,
		arg.VehicleModel,
		arg.VehicleColor,
		arg.VehicleType,
		arg.ConfidenceMmr,
		arg.ConfidenceColor,
		arg.CameraSerial,
		arg.CameraIp,
		arg.RawJson,
		arg.CreatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertImage = `-- name: InsertImage :exec
INSERT INTO images (event_id, image_type, filename, image_data, created_at)
VALUES (?, ?, ?, ?, ?)
`

type InsertImageParams struct {
	EventID   int64     `json:"event_id"`
	ImageType *string   `json:"image_type"`
	Filename  *string   `json:"filename"`
	ImageData []byte    `json:"image_data"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) InsertImage(ctx context.Context, arg InsertImageParams) error {
	_, err := q.db.ExecContext(ctx, insertImage,
		arg.EventID,
		arg.ImageType,
		arg.Filename,
		arg.ImageData,
		arg.CreatedAt,
	)
	return err
}

const searchByPlate = `-- name: SearchByPlate :many
SELECT id, car_id, plate_utf8, car_state, sensor_provider_id, event_datetime, created_at
FROM events
WHERE plate_utf8 LIKE ?
ORDER BY created_at DESC
LIMIT ?
`

type SearchByPlateParams struct {
	PlateUtf8 *string `json:"plate_utf8"`
	Limit     int64   `json:"limit"`
}

type SearchByPlateRow struct {
	ID               int64     `json:"id"`
	CarID            string    `json:"car_id"`
	PlateUtf8        *string   `json:"plate_utf8"`
	CarState         *string   `json:"car_state"`
	SensorProviderID *string   `json:"sensor_provider_id"`
	EventDatetime    *string   `json:"event_datetime"`
	CreatedAt        time.Time `json:"created_at"`
}

func (q *Queries) SearchByPlate(ctx context.Context, arg SearchByPlateParams) ([]SearchByPlateRow, error) {
	rows, err := q.db.QueryContext(ctx, searchByPlate, arg.PlateUtf8, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchByPlateRow{}
	for rows.Next() {
		var i SearchByPlateRow
		if err := rows.Scan(
			&i.ID,
			&i.CarID,
			&i.PlateUtf8,
			&i.CarState,
			&i.SensorProviderID,
			&i.EventDatetime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCompareResult = `-- name: SetCompareResult :exec
INSERT INTO compare_results (archive_id, event_id, field, is_incorrect, updated_at)
VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(archive_id, event_id, field) DO UPDATE SET
    is_incorrect = excluded.is_incorrect,
    updated_at = CURRENT_TIMESTAMP
`

type SetCompareResultParams struct {
	ArchiveID   int64  `json:"archive_id"`
	EventID     int64  `json:"event_id"`
	Field       string `json:"field"`
	IsIncorrect bool   `json:"is_incorrect"`
}

func (q *Queries) SetCompareResult(ctx context.Context, arg SetCompareResultParams) error {
	_, err := q.db.ExecContext(ctx, setCompareResult,
		arg.ArchiveID,
		arg.EventID,
		arg.Field,
		arg.IsIncorrect,
	)
	return err
}

const updateEventJsonFilename = `-- name: UpdateEventJsonFilename :exec
UPDATE events SET json_filename = ? WHERE id = ?
`

type UpdateEventJsonFilenameParams struct {
	JsonFilename *string `json:"json_filename"`
	ID           int64   `json:"id"`
}

func (q *Queries) UpdateEventJsonFilename(ctx context.Context, arg UpdateEventJsonFilenameParams) error {
	_, err := q.db.ExecContext(ctx, updateEventJsonFilename, arg.JsonFilename, arg.ID)
	return err
}

const updateImageDiskFilename = `-- name: UpdateImageDiskFilename :exec
UPDATE images SET disk_filename = ? WHERE id = ?
`

type UpdateImageDiskFilenameParams struct {
	DiskFilename *string `json:"disk_filename"`
	ID           int64   `json:"id"`
}

func (q *Queries) UpdateImageDiskFilename(ctx context.Context, arg UpdateImageDiskFilenameParams) error {
	_, err := q.db.ExecContext(ctx, updateImageDiskFilename, arg.DiskFilename, arg.ID)
	return err
}
